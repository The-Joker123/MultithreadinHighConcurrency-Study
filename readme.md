synchronized的底层实现
JDK早期的 是重量级锁
_Mark Word是对象头的一部分；每个线程都拥有自己的线程栈（虚拟机栈），记录线程和函数调用的基本信息。二者属于JVM的基础内容，此处不做介绍。_
**重量级锁**
内置锁在Java中被抽象为监视器锁（monitor）。在JDK 1.6之前，监视器锁可以认为直接对应底层操作系统中的互斥量（mutex）。这种同步方式的成本非常高，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。因此，后来称这种锁为“重量级锁”。
后来改进
如果只有一个线程，会申请为偏向锁
**偏向锁**
 “偏向”的意思是，偏向锁假定将来只有第一个申请锁的线程会使用锁（不会有任何线程再来申请锁），因此，只需要在Mark Word中CAS记录owner（本质上也是更新，但初始值为空），如果记录成功，则偏向锁获取成功，记录锁状态为偏向锁，以后当前线程等于owner就可以零成本的直接获得锁；否则，说明有其他线程竞争，膨胀为轻量级锁。
 
 偏向锁无法使用自旋锁优化，因为一旦有其他线程申请锁，就破坏了偏向锁的假定。
 
 如果线程争用：升级为 自旋锁
 
 _当前线程竞争锁失败时，打算阻塞自己
 不直接阻塞自己，而是自旋（空等待，比如一个空的有限for循环）一会
 在自旋的同时重新竞争锁
 如果自旋结束前获得了锁，那么锁获取成功；否则，自旋结束后阻塞自己_ 